# pla.scala

## object pla

注释不太看得懂，但是用了示例转成verilog试了一下，传入的函数是输入输出BitPat组两两对应

### def apply(table: Seq[(BitPat, BitPat)], invert: BitPat = BitPat("b0")): (UInt, UInt)  

要求输入表非空 invert是输出反相的位置标识，需要反相的位置标1
拆分了输入输出表，要求输入输出的表宽度都要是相同的,invert也需要和输出同宽
记录了输入表的项数量和输出表的项位宽
创建了输入和输入反相的线,创建了输出的线，上述线位宽与传入BitPat位宽相等
通过遍历输入表各个表项的mask和value来为每个表项创建真值表和BitPat到线与逻辑的映射
创建一宽度与输出宽度相等的序列，遍历每个位，先滤出输出表中当前遍历位为'1'的项保留，然后再将匹配的所有的项对应输入的BitPat表示送入前面得到的BitPat到线与逻辑的映射表得出对应的线与逻辑，成为当前位的表项,将当前位的表项相或得到当前位输出的与或逻辑,依次遍历每个位，然后倒序拼接成为输出
同时得出了反逻辑矩阵的输出，就是将与反相位为'1'的位对应的位输出置反。连接到输出返回
